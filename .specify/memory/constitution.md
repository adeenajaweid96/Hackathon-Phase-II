<!--
Sync Impact Report:
Version Change: [INITIAL] → 1.0.0
Modified Principles: N/A (initial constitution)
Added Sections:
  - Core Principles (6 principles)
  - Technology Stack Requirements
  - Development Workflow
  - Quality Gates
  - Governance
Templates Requiring Updates:
  ✅ .specify/templates/plan-template.md (verified alignment)
  ✅ .specify/templates/spec-template.md (verified alignment)
  ✅ .specify/templates/tasks-template.md (verified alignment)
  ✅ .specify/templates/commands/*.md (verified agent references)
Follow-up TODOs: None
-->

# Multi-User Todo Web Application Constitution

## Core Principles

### I. Spec-Driven Development (NON-NEGOTIABLE)

All development MUST follow the spec-driven workflow: Write spec → Generate plan → Break into tasks → Implement via Claude Code. No implementation may begin before specification approval. Each specification must be complete, unambiguous, and testable before planning begins. Planning output must explicitly reference specification sections. Tasks must map one-to-one with plan items. Implementation must match task definitions exactly.

**Rationale**: Deterministic and reproducible outputs require clear specifications. Spec-first development prevents scope creep, ensures traceability, and enables proper agent coordination.

### II. Agent-Only Implementation (NON-NEGOTIABLE)

Zero manual code edits are permitted. All code must be generated by Claude Code agents following approved specifications and plans. Developers may only modify specifications, plans, and task definitions—never implementation code directly. Any code changes must flow through the spec → plan → tasks → implement workflow.

**Rationale**: Agent-generated code ensures consistency with specifications, maintains traceability, and prevents undocumented changes that break the spec-driven contract.

### III. Stack-Specific Agent Assignment (MANDATORY)

Each technology layer MUST be implemented by its designated specialized agent:
- **Authentication & Security** → `secure-auth-advisor` agent (Better Auth, JWT, session management)
- **Frontend Development** → `nextjs-performance-architect` agent (Next.js 16+ App Router, responsive UI)
- **Database Operations** → `neon-db-optimizer` agent (Neon PostgreSQL, SQLModel, migrations)
- **Backend API Development** → `fastapi-performance-optimizer` agent (FastAPI endpoints, performance)

**Rationale**: Specialized agents have domain expertise and optimized tooling for their stack layer. Cross-layer work by generalist agents risks suboptimal implementations and security vulnerabilities.

### IV. Security-First Authentication (NON-NEGOTIABLE)

All authentication and authorization must be implemented using Better Auth with JWT tokens. Every backend API endpoint MUST verify JWT tokens and extract user identity. Users MUST only access their own data—no cross-user data leakage permitted. JWT secrets MUST never be exposed in client-side code. Invalid or expired tokens MUST be rejected with proper error handling.

**Rationale**: Multi-user applications require strict data isolation. Security vulnerabilities in authentication can compromise all user data. Better Auth provides battle-tested patterns; deviations introduce risk.

### V. Multi-User Data Isolation (NON-NEGOTIABLE)

Database schema and API logic MUST enforce strict user data separation. Every data query MUST filter by authenticated user ID. User ID from JWT token MUST match user ID in request URL/body. Database migrations MUST safely support multi-user data without conflicts. All features MUST be testable for cross-user data leakage.

**Rationale**: Data isolation is a fundamental security requirement. A single query without user filtering can expose all users' data. Schema design must prevent accidental cross-user access.

### VI. Technology Stack Compliance (MANDATORY)

The following technology stack is mandatory and non-negotiable:
- **Frontend**: Next.js 16+ with App Router (no Pages Router)
- **Backend**: Python FastAPI (no Flask, Django, or alternatives)
- **ORM**: SQLModel (no raw SQL, SQLAlchemy Core, or other ORMs)
- **Database**: Neon Serverless PostgreSQL (no local PostgreSQL, MySQL, or other databases)
- **Authentication**: Better Auth with JWT tokens (no custom auth, Passport.js, or alternatives)

**Rationale**: Stack consistency ensures specialized agents can operate effectively. Version requirements prevent compatibility issues. Deviations break agent assumptions and introduce maintenance burden.

## Technology Stack Requirements

### Frontend Layer
- Next.js 16+ with App Router architecture
- Responsive, mobile-first UI design
- Client/Server component separation following Next.js best practices
- Environment-based configuration for API endpoints
- No hardcoded credentials or secrets in client code

### Backend Layer
- Python FastAPI with async/await patterns
- RESTful API design with consistent JSON responses
- JWT token verification on all protected endpoints
- SQLModel for database operations (no raw SQL)
- Environment-based configuration for database and secrets

### Database Layer
- Neon Serverless PostgreSQL
- SQLModel schema definitions
- Database migrations for schema changes
- Multi-user data isolation at schema level
- Connection pooling and performance optimization

### Authentication Layer
- Better Auth for user signup and signin
- JWT token generation and verification
- Secure session management
- Password hashing and validation
- Token expiration and refresh handling

## Development Workflow

### Phase 1: Specification
1. Write complete feature specification using `/sp.specify`
2. Specification must define all user actions, API endpoints, data models, and validation rules
3. Specification must be reviewed and approved before proceeding
4. Ambiguities must be resolved via clarification questions

### Phase 2: Planning
1. Generate architectural plan using `/sp.plan`
2. Plan must reference specification sections explicitly
3. Plan must assign work to appropriate specialized agents
4. Architectural decisions must be documented in ADRs when significant

### Phase 3: Task Breakdown
1. Generate actionable tasks using `/sp.tasks`
2. Tasks must map one-to-one with plan items
3. Tasks must include acceptance criteria and test cases
4. Task dependencies must be explicitly defined

### Phase 4: Implementation
1. Execute tasks using `/sp.implement`
2. Appropriate specialized agent must be invoked for each task
3. Implementation must match task definitions exactly
4. No manual code edits permitted during implementation

### Phase 5: Validation
1. All features must be testable via both UI and API
2. Authentication and authorization must be verified
3. Multi-user data isolation must be tested
4. Cross-user data leakage tests must pass

## Quality Gates

### Specification Gate
- [ ] All user actions explicitly defined
- [ ] All API endpoints documented with request/response schemas
- [ ] All data models defined with validation rules
- [ ] Authentication and authorization requirements specified
- [ ] Multi-user data isolation requirements documented

### Planning Gate
- [ ] Plan references specification sections
- [ ] Specialized agents assigned to appropriate work
- [ ] Architectural decisions documented in ADRs
- [ ] Technology stack compliance verified
- [ ] Security considerations addressed

### Task Gate
- [ ] Tasks map one-to-one with plan items
- [ ] Acceptance criteria defined for each task
- [ ] Test cases included for each task
- [ ] Task dependencies explicitly defined
- [ ] Specialized agent assignments confirmed

### Implementation Gate
- [ ] Code generated by appropriate specialized agents
- [ ] Implementation matches task definitions
- [ ] No manual code edits performed
- [ ] Environment-based configuration used
- [ ] No hardcoded secrets or credentials

### Validation Gate
- [ ] All features testable via UI and API
- [ ] Unauthenticated access to protected routes rejected
- [ ] Users can only access their own data
- [ ] Cross-user data leakage tests pass
- [ ] Database schema supports multi-user data safely

## Governance

This constitution supersedes all other development practices and guidelines. All specifications, plans, tasks, and implementations must comply with these principles. Non-compliance must be identified and corrected before proceeding to the next phase.

### Amendment Process
1. Proposed amendments must be documented with rationale
2. Impact analysis must identify affected templates and artifacts
3. Version must be incremented according to semantic versioning:
   - **MAJOR**: Backward incompatible principle removals or redefinitions
   - **MINOR**: New principles or materially expanded guidance
   - **PATCH**: Clarifications, wording fixes, non-semantic refinements
4. Dependent templates must be updated to maintain consistency
5. Sync Impact Report must be generated and prepended to constitution

### Compliance Review
- All PRs and reviews must verify constitutional compliance
- Violations must be rejected with reference to specific principle
- Complexity must be justified against simplicity principles
- Security requirements must be verified at each quality gate

### Version Control
- Constitution changes must be committed with descriptive messages
- Version history must be preserved in git
- Breaking changes must be communicated to all stakeholders
- Migration plans required for backward-incompatible changes

**Version**: 1.0.0 | **Ratified**: 2026-02-05 | **Last Amended**: 2026-02-05
